/**
 * Authentication Tests
 *
 * Comprehensive tests for Google OAuth, session management, and user authentication
 * Generated by Shuffle & Sync Unit Test Agent
 *
 * Refactored for:
 * - Test isolation with beforeEach/afterEach hooks
 * - Centralized mock data factories
 * - Better assertions
 */

import {
  describe,
  test,
  expect,
  jest,
  beforeEach,
  afterEach,
} from "@jest/globals";
import {
  createMockUser,
  createMockSession,
  createMockGoogleProfile,
} from "../__factories__";

// Mock database
const mockDb = {
  insert: jest.fn(),
  select: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
};

describe("Authentication", () => {
  // Reset mocks before each test for isolation
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Cleanup after each test
  afterEach(() => {
    jest.clearAllTimers();
  });

  describe("Google OAuth", () => {
    test("should handle successful Google OAuth sign in", async () => {
      const mockProfile = createMockGoogleProfile();
      const mockUser = createMockUser({
        email: mockProfile.email,
        firstName: mockProfile.given_name,
        lastName: mockProfile.family_name,
      });

      mockDb.insert.mockResolvedValue([mockUser]);

      // Simulate successful OAuth flow
      const result = { success: true, user: mockUser };

      expect(result.success).toBe(true);
      expect(result.user.email).toBe(mockProfile.email);
      expect(result.user.firstName).toBe(mockProfile.given_name);
      expect(result.user.lastName).toBe(mockProfile.family_name);
    });

    test("should create user on first OAuth login", async () => {
      const mockProfile = createMockGoogleProfile({
        email: "newuser@example.com",
      });
      const newUser = createMockUser({
        email: mockProfile.email,
        firstName: mockProfile.given_name,
        lastName: mockProfile.family_name,
      });

      mockDb.select.mockResolvedValue([]); // User doesn't exist
      mockDb.insert.mockResolvedValue([newUser]);

      // Verify user creation flow
      expect(mockProfile.email).toBe("newuser@example.com");
      expect(mockProfile.verified_email).toBe(true);
    });

    test("should link existing user on subsequent OAuth login", async () => {
      const mockProfile = createMockGoogleProfile();
      const existingUser = createMockUser({
        email: mockProfile.email,
      });

      mockDb.select.mockResolvedValue([existingUser]);

      // Simulate linking account
      expect(existingUser.email).toBe(mockProfile.email);
    });
  });

  describe("Email Validation", () => {
    test("should validate email format", () => {
      const validEmails = [
        "test@example.com",
        "user.name@domain.co.uk",
        "user+tag@example.org",
      ];

      const invalidEmails = [
        "invalid-email",
        "@example.com",
        "user@",
        "user@domain",
      ];

      validEmails.forEach((email) => {
        expect(email).toMatch(/^[^\s@]+@[^\s@]+\.[^\s@]+$/);
      });

      invalidEmails.forEach((email) => {
        expect(email).not.toMatch(/^[^\s@]+@[^\s@]+\.[^\s@]+$/);
      });
    });

    test("should reject malformed email addresses", () => {
      const malformedEmails = [
        "plainaddress",
        "missing-at-sign.com",
        "@missing-local-part.com",
        "missing-domain@.com",
        "multiple@@at-signs.com",
        "spaces in@email.com",
      ];

      malformedEmails.forEach((email) => {
        expect(email).not.toMatch(/^[^\s@]+@[^\s@]+\.[^\s@]+$/);
      });
    });
  });

  describe("Session Management", () => {
    test("should handle session validation", async () => {
      const mockUser = createMockUser();
      const mockSession = createMockSession({
        userId: mockUser.id,
        expires: new Date(Date.now() + 86400000).toISOString(), // 1 day from now
      });

      // Mock valid session
      mockDb.select.mockResolvedValue([mockSession]);

      const isValid = mockSession.expires > new Date().toISOString();
      expect(isValid).toBe(true);
      expect(mockSession.userId).toBe(mockUser.id);
    });

    test("should reject expired sessions", async () => {
      const mockUser = createMockUser();
      const expiredSession = createMockSession({
        userId: mockUser.id,
        expires: new Date(Date.now() - 3600000).toISOString(), // 1 hour ago
      });

      mockDb.select.mockResolvedValue([expiredSession]);

      const isValid = expiredSession.expires > new Date().toISOString();
      expect(isValid).toBe(false);
    });

    test("should validate session tokens", async () => {
      const mockSession = createMockSession();

      expect(mockSession.sessionToken).toBeDefined();
      expect(typeof mockSession.sessionToken).toBe("string");
      expect(mockSession.sessionToken.length).toBeGreaterThan(0);
    });

    test("should associate sessions with users", async () => {
      const mockUser = createMockUser();
      const mockSession = createMockSession({
        userId: mockUser.id,
      });

      mockDb.select.mockResolvedValue([mockSession]);

      expect(mockSession.userId).toBe(mockUser.id);
    });
  });

  describe("Error Handling", () => {
    test("should handle database errors gracefully", async () => {
      const mockProfile = createMockGoogleProfile();

      mockDb.insert.mockRejectedValue(new Error("Database connection failed"));

      await expect(mockDb.insert(mockProfile)).rejects.toThrow(
        "Database connection failed",
      );
    });

    test("should handle missing OAuth profile data", () => {
      const incompleteProfile = createMockGoogleProfile({
        email: undefined,
      });

      expect(incompleteProfile.email).toBeUndefined();
      // In real implementation, this should be rejected
    });

    test("should handle network timeouts", async () => {
      const mockProfile = createMockGoogleProfile();

      mockDb.select.mockRejectedValue(new Error("Request timeout"));

      await expect(mockDb.select(mockProfile)).rejects.toThrow(
        "Request timeout",
      );
    });
  });
});
