/**
 * AI Matchmaking Tests
 * 
 * Tests for AI-powered matchmaking algorithms and edge case handling
 * Generated by Shuffle & Sync Unit Test Agent
 */

import { describe, test, expect, jest } from '@jest/globals';

const createMockMatchingCriteria = (overrides = {}) => ({
  userId: 'user-123',
  gameTypes: ['mtg'],
  skillLevel: 'intermediate',
  timezone: 'UTC-5',
  maxResults: 10,
  minCompatibilityScore: 0.6,
  ...overrides
});

const createMockMatch = (overrides = {}) => ({
  userId: 'user-456',
  compatibilityScore: 0.85,
  sharedInterests: ['mtg'],
  skillLevelMatch: 0.9,
  timezoneCompatibility: 0.8,
  ...overrides
});

describe('AI Matchmaking', () => {
  test('should calculate compatibility scores', () => {
    const user1 = { gameTypes: ['mtg', 'pokemon'], skillLevel: 'intermediate' };
    const user2 = { gameTypes: ['mtg'], skillLevel: 'intermediate' };
    
    // Simple compatibility calculation
    const sharedGames = user1.gameTypes.filter(game => user2.gameTypes.includes(game));
    const gameCompatibility = sharedGames.length / Math.max(user1.gameTypes.length, user2.gameTypes.length);
    const skillCompatibility = user1.skillLevel === user2.skillLevel ? 1.0 : 0.5;
    
    const overallScore = (gameCompatibility + skillCompatibility) / 2;
    
    expect(sharedGames).toContain('mtg');
    expect(overallScore).toBeGreaterThan(0.5);
    expect(overallScore).toBeLessThanOrEqual(1.0);
  });

  test('should handle empty match results', () => {
    const criteria = createMockMatchingCriteria({
      gameTypes: ['very-rare-game'],
      skillLevel: 'expert'
    });

    const matches: any[] = []; // Simulate no matches found
    
    expect(matches).toHaveLength(0);
  });

  test('should respect user filters', () => {
    const criteria = createMockMatchingCriteria({
      excludeUserIds: ['user-blocked'],
      minCompatibilityScore: 0.7
    });

    const allMatches = [
      createMockMatch({ userId: 'user-456', compatibilityScore: 0.9 }),
      createMockMatch({ userId: 'user-blocked', compatibilityScore: 0.8 }),
      createMockMatch({ userId: 'user-789', compatibilityScore: 0.6 })
    ];

    const filteredMatches = allMatches.filter(match => 
      !criteria.excludeUserIds.includes(match.userId) &&
      match.compatibilityScore >= criteria.minCompatibilityScore
    );

    expect(filteredMatches).toHaveLength(1);
    expect(filteredMatches[0].userId).toBe('user-456');
  });

  test('should sort matches by compatibility score', () => {
    const matches = [
      createMockMatch({ userId: 'user-1', compatibilityScore: 0.7 }),
      createMockMatch({ userId: 'user-2', compatibilityScore: 0.9 }),
      createMockMatch({ userId: 'user-3', compatibilityScore: 0.8 })
    ];

    const sortedMatches = matches.sort((a, b) => b.compatibilityScore - a.compatibilityScore);

    expect(sortedMatches[0].compatibilityScore).toBe(0.9);
    expect(sortedMatches[1].compatibilityScore).toBe(0.8);
    expect(sortedMatches[2].compatibilityScore).toBe(0.7);
  });

  test('should handle timezone compatibility', () => {
    const userTimezone = 'UTC-5';
    const partnerTimezones = ['UTC-5', 'UTC-6', 'UTC+3'];
    
    const timezoneScores = partnerTimezones.map(tz => {
      const userOffset = parseInt(userTimezone.split('UTC')[1]) || 0;
      const partnerOffset = parseInt(tz.split('UTC')[1]) || 0;
      const timeDiff = Math.abs(userOffset - partnerOffset);
      
      // Higher score for smaller time differences
      return Math.max(0, 1 - (timeDiff / 12));
    });

    expect(timezoneScores[0]).toBe(1.0); // Same timezone
    expect(timezoneScores[1]).toBeGreaterThan(timezoneScores[2]); // Closer timezone
  });
});
